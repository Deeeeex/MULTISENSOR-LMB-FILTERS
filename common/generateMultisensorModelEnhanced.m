function model = generateMultisensorModelEnhanced(numberOfSensors, clutterRates, detectionProbabilities, q, lmbParallelUpdateMode, dataAssociationMethod, varargin)
% GENERATEMULTISENSORMODELENHANCED - Enhanced version with extended sensor motion models
%   model =  generateMultisensorModelEnhanced(numberOfSensors, clutterRates, detectionProbabilities, q, lmbParallelUpdateMode, dataAssociationMethod, varargin)
%
%   Enhanced version supporting multiple sensor motion models: CV, CT, etc.
%
%   See also generateMultisensorModel
%
%   Inputs
%       numberOfSensors - integer. The number of sensors for simulation.
%       clutterRates - (1, s) array. The number of expected clutter per
%           time-step for each sensor. Clutter is assumed to generated by a Poisson point
%           process.
%       detectionProbabilities - (1, s) array. Each sensor's detection
%           probability.
%       lmbParallelUpdateMode - char array. Type of measurement update for
%           multi-sensor LMB filter: 'PU', 'AA', 'GA'. 'PU' is default.
%       q - (1, s) cell array. The standard deviation of each sensor's noise.
%           It is assumed that a sensor's noise covariance is given by
%           Q{i} = (q(i)^2) * eye(2, 2)
%       dataAssociationMethod - string. Type of data association method for the filters:
%           'LBP', 'Gibbs', 'Murty', 'LBPFixed'. LBP does not apply to LMBM filter.
%           'LBPFixed' uses a fixed number of iterations and is used to
%            experimentally verify the filter's asymptotic computational
%            complexity.
%       scenarioType - char array. Optional input: Type of simulated scenario.
%           'Fixed' - Four fixed birth locations.
%           'Random' - Randomly generated birth locations.
%       numberOfBirthLocations - integer. Optional input: Number of birth
%           locations for the 'Random' scenario.
%
%   Output
%       model - struct. A struct with the fields declared in this function.

%% Call base generateMultisensorModel
model = generateMultisensorModel(numberOfSensors, clutterRates, detectionProbabilities, ...
    q, lmbParallelUpdateMode, dataAssociationMethod, varargin{:});

%% Phase 2: Enhanced Sensor Motion Models

%% Parse enhanced sensor motion configuration
sensorMotionConfig = struct();
sensorMotionConfig.enabled = false;
sensorMotionConfig.motionType = 'CV'; % 'CV', 'CT', 'Formation'

% Check for enhanced sensor motion parameters
for i = 1:length(varargin)
    if isstruct(varargin{i}) && isfield(varargin{i}, 'motionType')
        sensorMotionConfig = varargin{i};
        break;
    end
end

%% Enhanced sensor motion support
if model.sensorMotionEnabled && ~isempty(sensorMotionConfig)
    model.sensorMotionType = sensorMotionConfig.motionType;

    %% CT (Coordinated Turn) motion model support
    if strcmp(sensorMotionConfig.motionType, 'CT')
        model.sensorTurnRate = sensorMotionConfig.turnRate;
        model.sensorTurnModel = sensorMotionConfig.turnModel; % 'ConstantTurn' or 'WhiteNoiseTurn'
    end

    %% Formation flight support
    if isfield(sensorMotionConfig, 'formation')
        model.sensorFormation = sensorMotionConfig.formation;
        model.formationSpeed = sensorMotionConfig.formationSpeed;
        model.formationCenter = sensorMotionConfig.formationCenter;
    end

    %% Adaptive sensor velocity
    if isfield(sensorMotionConfig, 'adaptiveVelocity')
        model.sensorAdaptiveVelocity = sensorMotionConfig.adaptiveVelocity;
        model.maxSensorVelocity = sensorMotionConfig.maxVelocity;
    end

    %% Sensor scheduling parameters
    if isfield(sensorMotionConfig, 'scheduling')
        model.sensorScheduling = sensorMotionConfig.scheduling;
        model.sensorSchedule = sensorMotionConfig.schedule;
    end

    %% Communication range
    if isfield(sensorMotionConfig, 'commRange')
        model.sensorCommRange = sensorMotionConfig.commRange;
    end
end

end
