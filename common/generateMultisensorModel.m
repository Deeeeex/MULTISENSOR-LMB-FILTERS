function model = generateMultisensorModel(numberOfSensors, clutterRates, detectionProbabilities, q, lmbParallelUpdateMode, dataAssociationMethod, varargin)
% GENERATEMULTISENSORMODEL -- Generates a structure containing all simulation info.
%   model =  generateMultisensorModel(numberOfSensors, clutterRates, detectionProbabilities, q, lmbParallelUpdateMode, dataAssociationMethod, varargin)
%
%   Declares all multi-sensor simulation information, except the ground truth.
%
%   See also generateGroundTruth.
%
%   Inputs
%       numberOfSensors - integer. The number of sensors for the
%           simulation.
%       clutterRates - (1, s) array. The number of expected clutter per
%           time-step for each sensor. Clutter is assumed to generated by a Poisson point
%           process.
%       detectionProbabilities - (1, s) array. Each sensor's detection
%           probability.
%       lmbParallelUpdateMode - char array. Type of measurement update for
%           the multi-sensor LMB filter: 'PU', 'AA', 'GA'. 'PU' is default. 
%       q - (1, s) cell array. The standard deviation of each sensor's noise.
%           It is assumed that a sensor's noise covariance is given by 
%           Q{i} = (q(i)^2) * eye(2, 2)
%       dataAssociationMethod - string. Type of data association method for the filters:
%           'LBP', 'Gibbs', 'Murty', 'LBPFixed'. LBP does not apply to LMBM filter.
%           'LBPFixed' uses a fixed number of iterations and is used to
%            experimentally verify the filter's asymptotic computational
%            complexity.
%       scenarioType - char array. Optional input: Type of simulated scenario.
%           'Fixed' - Four fixed birth locations.
%           'Random' - Randomly generated birth locations.
%       numberOfBirthLocations - integer. Optional input: Number of birth 
%           locations for the 'Random' scenario. 
%
%   Output
%       model - struct. A struct with the fields declared in this function.

%% Very dodgy input checking
model.sensorMotionEnabled = false; % Default: sensors are static
model.targetFormationEnabled = false; % Default: targets are not in formation

numberOfBirthLocations = [];
if (nargin > 6)
    % Get input
    if (ischar(varargin{1}))
        model.scenarioType = varargin{1};
        if (strcmp(model.scenarioType, 'Random'))
            if (nargin > 7)
                numberOfBirthLocations = varargin{2};
            else
                error('You must specify the number of birth locations');
            end
        end
    else
        model.scenarioType = 'Fixed';
    end
    % Check input
    if ~(strcmp(model.scenarioType, 'Fixed') || (strcmp(model.scenarioType, 'Random')) || ...
            (strcmp(model.scenarioType, 'Coalescence')) || (strcmp(model.scenarioType, 'Formation')))
        error('Scenario type must be Fixed, Random, Coalescence, or Formation');
    end
else
    model.scenarioType = 'Fixed';
end

%% Parse sensor motion configuration (optional)
sensorMotionConfig = struct();
sensorMotionConfig.enabled = false;

% Check for sensor motion parameters in varargin
sensorMotionParamIdx = -1;
for i = 1:length(varargin)
    if isstruct(varargin{i}) && isfield(varargin{i}, 'enabled') && ~isfield(varargin{i}, 'targetFormationEnabled')
        sensorMotionConfig = varargin{i};
        sensorMotionParamIdx = i;
        break;
    end
end
% Check for target formation parameters in varargin
targetFormationConfig = struct();
targetFormationConfig.targetFormationEnabled = false;
for i = 1:length(varargin)
    if isstruct(varargin{i}) && isfield(varargin{i}, 'targetFormationEnabled')
        targetFormationConfig = varargin{i};
        break;
    end
end

if ~isempty(sensorMotionConfig) && isfield(sensorMotionConfig, 'enabled') && sensorMotionConfig.enabled
    model.sensorMotionEnabled = true;
    if isfield(sensorMotionConfig, 'motionType')
        model.sensorMotionType = sensorMotionConfig.motionType;
    else
        model.sensorMotionType = 'CV';
    end
    if isfield(sensorMotionConfig, 'processNoiseStd')
        model.sensorProcessNoiseStd = sensorMotionConfig.processNoiseStd;
    else
        model.sensorProcessNoiseStd = 0.05;
    end
    if isfield(sensorMotionConfig, 'initialStates')
        model.sensorInitialStates = sensorMotionConfig.initialStates;
    else
        model.sensorInitialStates = cell(1, numberOfSensors);
    end
    % Formation motion parameters (optional)
    if isfield(sensorMotionConfig, 'formationType')
        model.sensorFormationType = sensorMotionConfig.formationType;
    elseif isfield(sensorMotionConfig, 'formation')
        model.sensorFormationType = sensorMotionConfig.formation;
    else
        model.sensorFormationType = 'Triangle';
    end
    if isfield(sensorMotionConfig, 'formationSpacing')
        model.sensorFormationSpacing = sensorMotionConfig.formationSpacing;
    else
        model.sensorFormationSpacing = 20;
    end
    if isfield(sensorMotionConfig, 'formationCenterStart')
        model.sensorFormationCenterStart = sensorMotionConfig.formationCenterStart;
    elseif isfield(sensorMotionConfig, 'formationCenter')
        model.sensorFormationCenterStart = sensorMotionConfig.formationCenter;
    else
        model.sensorFormationCenterStart = [-80; 0];
    end
    model.sensorFormationCenterStart = model.sensorFormationCenterStart(:);
    if isfield(sensorMotionConfig, 'formationVelocity')
        model.sensorFormationVelocity = sensorMotionConfig.formationVelocity;
    elseif isfield(sensorMotionConfig, 'formationSpeed')
        model.sensorFormationVelocity = [sensorMotionConfig.formationSpeed; 0];
    else
        model.sensorFormationVelocity = [0.8; 0];
    end
    model.sensorFormationVelocity = model.sensorFormationVelocity(:);
    % CT motion parameters (optional)
    if isfield(sensorMotionConfig, 'turnRate')
        model.sensorTurnRate = sensorMotionConfig.turnRate;
    end
    if isfield(sensorMotionConfig, 'turnModel')
        model.sensorTurnModel = sensorMotionConfig.turnModel;
    end
else
    model.sensorMotionEnabled = false;
end
%% Target formation configuration (optional)
if ~isempty(targetFormationConfig) && isfield(targetFormationConfig, 'targetFormationEnabled') ...
        && targetFormationConfig.targetFormationEnabled
    model.targetFormationEnabled = true;
    model.scenarioType = 'Formation';
    if isfield(targetFormationConfig, 'targetFormationType')
        model.targetFormationType = targetFormationConfig.targetFormationType;
    else
        model.targetFormationType = 'Triangle';
    end
    if isfield(targetFormationConfig, 'targetFormationSpacing')
        model.targetFormationSpacing = targetFormationConfig.targetFormationSpacing;
    else
        model.targetFormationSpacing = 15;
    end
    if isfield(targetFormationConfig, 'targetFormationCenter')
        model.targetFormationCenter = targetFormationConfig.targetFormationCenter;
    else
        model.targetFormationCenter = [60; 0];
    end
    model.targetFormationCenter = model.targetFormationCenter(:);
    if isfield(targetFormationConfig, 'targetFormationVelocity')
        model.targetFormationVelocity = targetFormationConfig.targetFormationVelocity;
    else
        model.targetFormationVelocity = [0.3; 0];
    end
    model.targetFormationVelocity = model.targetFormationVelocity(:);
    if isfield(targetFormationConfig, 'targetBirthStates')
        model.targetBirthStates = targetFormationConfig.targetBirthStates;
        if isfield(targetFormationConfig, 'targetFormationCount')
            model.targetFormationCount = targetFormationConfig.targetFormationCount;
        else
            model.targetFormationCount = size(model.targetBirthStates, 2);
        end
    end
    if isfield(targetFormationConfig, 'targetFormationCount')
        model.targetFormationCount = targetFormationConfig.targetFormationCount;
    else
        model.targetFormationCount = 3;
    end
    if isfield(targetFormationConfig, 'targetFormationStaggeredBirths')
        model.targetFormationStaggeredBirths = targetFormationConfig.targetFormationStaggeredBirths;
    else
        model.targetFormationStaggeredBirths = false;
    end
    if isfield(targetFormationConfig, 'targetFormationBirthInterval')
        model.targetFormationBirthInterval = targetFormationConfig.targetFormationBirthInterval;
    else
        model.targetFormationBirthInterval = 5;
    end
    if isfield(targetFormationConfig, 'targetFormationStartTime')
        model.targetFormationStartTime = targetFormationConfig.targetFormationStartTime;
    else
        model.targetFormationStartTime = 1;
    end
    if isfield(targetFormationConfig, 'targetFormationLifeSpan')
        model.targetFormationLifeSpan = targetFormationConfig.targetFormationLifeSpan;
    else
        model.targetFormationLifeSpan = 100;
    end
else
    model.targetFormationEnabled = false;
end
%% State and measurement space dimensions
model.xDimension = 4;
model.zDimension = 2;
%% Sampling period
model.T = 1;
%% Linear motion model
% State transition matrix
model.survivalProbability = 0.95; % Existing target survival probability - could be state dependent.
model.existenceThreshold = 1e-2;
model.A = [ eye(model.xDimension/2) model.T*eye(model.xDimension/2); ...
    zeros(model.xDimension/2) eye(model.xDimension/2)];
model.u = zeros(model.xDimension, 1);
% Process noise
r0 = 1;
model.R = r0*[ (1/3)*(model.T^3)*eye(model.xDimension/2) 0.5*(model.T^2)*eye(model.xDimension/2);
    0.5*(model.T^2)*eye(model.xDimension/2) model.T*eye(model.xDimension/2)];
%% Linear observation model
model.numberOfSensors = numberOfSensors;
% Observation matrix
model.C = repmat({[ eye(model.zDimension) zeros(model.zDimension) ]}, 1, model.numberOfSensors);
% Measurement noise
model.Q = cell(1, model.numberOfSensors);
for i = 1:model.numberOfSensors
    model.Q{i} = (q(i)^2) * eye(model.zDimension);
end
% Detection probability
model.detectionProbability = reshape(detectionProbabilities, model.numberOfSensors, 1); % Could be state dependent.
%% Observation space
model.observationSpaceLimits = 100*[-1 1; -1 1];
model.observationSpaceVolume = prod(model.observationSpaceLimits(:, 2) - model.observationSpaceLimits(:, 1));
model.clutterRate = clutterRates;
model.clutterPerUnitVolume = clutterRates/model.observationSpaceVolume;
%% Birth parameters
% Determine spawning locations
if (strcmp(model.scenarioType, 'Fixed'))
    % Four fixed birth locations
    model.numberOfBirthLocations = 4;
    birthLocations = [-80.0 -20.0 0.0 40.0;
                -20.0 80.0 0.0 -60.0;
                0.0 0.0 0.0 0.0;
                0.0 0.0 0.0 0.0];
elseif (strcmp(model.scenarioType, 'Random'))
    % Random birth locations
    model.numberOfBirthLocations = numberOfBirthLocations;
    birthLocations = zeros(model.xDimension, numberOfBirthLocations);
    birthLocations(1:2, :) = 0.5 * model.observationSpaceLimits(:, 1) + model.observationSpaceLimits(:, 2) .* rand(model.zDimension, numberOfBirthLocations);
elseif (strcmp(model.scenarioType, 'Formation'))
    % Formation birth locations (right side or custom)
    if isfield(model, 'targetBirthStates') && ~isempty(model.targetBirthStates)
        birthLocations = model.targetBirthStates;
        if size(birthLocations, 1) == 2
            birthLocations = [birthLocations; zeros(2, size(birthLocations, 2))];
        end
        model.numberOfBirthLocations = size(birthLocations, 2);
    else
        if ~isfield(model, 'targetFormationCount')
            model.targetFormationCount = 3;
        end
        if ~isfield(model, 'targetFormationType')
            model.targetFormationType = 'Triangle';
        end
        if ~isfield(model, 'targetFormationSpacing')
            model.targetFormationSpacing = 15;
        end
        if ~isfield(model, 'targetFormationCenter')
            model.targetFormationCenter = [60; 0];
        end
        if ~isfield(model, 'targetFormationVelocity')
            model.targetFormationVelocity = [0.3; 0];
        end
        model.numberOfBirthLocations = model.targetFormationCount;
        offsets = computeFormationOffsets(model.targetFormationType, model.targetFormationSpacing, model.numberOfBirthLocations);
        birthLocations = zeros(model.xDimension, model.numberOfBirthLocations);
        birthLocations(1:2, :) = model.targetFormationCenter + offsets;
        birthLocations(3, :) = model.targetFormationVelocity(1);
        birthLocations(4, :) = model.targetFormationVelocity(2);
    end
end
model.birthLocationLabels = 1:model.numberOfBirthLocations;
model.rB = 0.03 * ones(model.numberOfBirthLocations, 1);
model.rBLmbm = 0.06 * ones(model.numberOfBirthLocations, 1); %0.3 for a higher number of clutter returns
model.muB = repmat({zeros(model.xDimension, 1)}, model.numberOfBirthLocations, 1);
model.SigmaB = repmat( {diag( 10 * ones(model.xDimension, 1)  ).^2}, model.numberOfBirthLocations, 1);
% Copy matrix into cell
for i = 1:model.numberOfBirthLocations
    model.muB{i} = birthLocations(:, i);
end
%% Object struct
object.birthLocation = 0;
object.birthTime = 0;
object.r = 0;
object.numberOfGmComponents = 0;
object.w = zeros(0, 1);
object.mu = repmat({}, 0, 1);
object.Sigma = repmat({}, 0, 1);
object.trajectoryLength = 0;
object.trajectory = [];
object.timestamps = zeros(1, 0);
object = repmat(object, 0, 1);
%% LMBM trajectory structs
trajectory.birthLocation = 0;
trajectory.birthTime = 0;
% trajectory.r = [];
trajectory.trajectory = [];
trajectory.trajectoryLength = 0;
trajectory.timestamps = zeros(1, 0);
birthTrajectory = repmat(trajectory, 1, model.numberOfBirthLocations);
%% Birth object struct
birthParameters = repmat(object, model.numberOfBirthLocations, 1);
for i = 1:model.numberOfBirthLocations
    birthParameters(i).birthLocation = model.birthLocationLabels(i);
    birthParameters(i).birthTime = 0;
    birthParameters(i).r = model.rB(i);
    birthParameters(i).numberOfGmComponents = 1;
    birthParameters(i).w = ones(1, 1);
    birthParameters(i).mu = model.muB(i);
    birthParameters(i).Sigma = model.SigmaB(i);
    % Trajectory
    birthParameters(i).trajectoryLength = 0;
    birthParameters(i).trajectory = nan(model.xDimension, 100);
    birthParameters(i).timestamps = zeros(1, 100);
    % LMBM Birth trajectory
    birthTrajectory(i).birthLocation = model.birthLocationLabels(i);
    birthTrajectory(i).trajectoryLength = 0;
    birthTrajectory(i).trajectory = nan(model.xDimension, 100);
    birthTrajectory(i).timestamps = zeros(1, 100);
end
%% Hypothesis struct
hypotheses.birthLocation = zeros(0, 1);
hypotheses.birthTime = zeros(0, 1);
hypotheses.w = 1; % Hypothesis weight, lowercase sigma in the theory
hypotheses.r = zeros(0, 1);
hypotheses.mu = repmat({}, 0, 1);
hypotheses.Sigma = repmat({}, 0, 1);
%% Object structs
model.object = object;
model.birthParameters = birthParameters;
model.hypotheses = hypotheses;
%% LMBM trajectory structs
model.trajectory = repmat(trajectory, 1, 0);
model.birthTrajectory = birthTrajectory;
%% GM parameters
model.gmWeightThreshold = 1e-6;
model.maximumNumberOfGmComponents = 20;
%% Track parameters
model.minimumTrajectoryLength = 20;
%% Data association method
model.dataAssociationMethod = dataAssociationMethod;
%% Loopy belief propagation parameters
model.maximumNumberOfLbpIterations = 1e3;
model.lbpConvergenceTolerance = 1e-6;
%% Gibbs sampling parameters
model.numberOfSamples = 1e3;
%% Number of posterior hypothesis
model.maximumNumberOfPosteriorHypotheses = 10;
%% Posterior hypothesis weight threshold
model.posteriorHypothesisWeightThreshold = 1e-3;
%% OSPA parameters
model.ospaParameters.eC = 5; % Euclidean cut-off
model.ospaParameters.eP = 2;
model.ospaParameters.hC = 0.5; % Hellinger cut-off
model.ospaParameters.hP = 2;
%% LMB approximate update model
model.lmbParallelUpdateMode = lmbParallelUpdateMode;
%% AA-LMB parameters
model.aaSensorWeights = ones(1, model.numberOfSensors) / model.numberOfSensors;
%% GA-LMB parameters
model.gaSensorWeights = ones(1, model.numberOfSensors) / model.numberOfSensors;
%% Sensor motion parameters (Phase 1: Basic Framework)
if model.sensorMotionEnabled
    model.sensorProcessNoise = cell(1, model.numberOfSensors);
    for i = 1:model.numberOfSensors
        model.sensorProcessNoise{i} = (model.sensorProcessNoiseStd^2) * eye(4);
    end
end
end

function offsets = computeFormationOffsets(formationType, spacing, count)
% COMPUTEFORMATIONOFFSETS - Relative offsets for formation geometry
    if nargin < 3
        count = 3;
    end
    if nargin < 2
        spacing = 15;
    end
    if nargin < 1 || isempty(formationType)
        formationType = 'Triangle';
    end
    formationType = upper(formationType);
    switch formationType
        case 'TRIANGLE'
            radius = spacing / sqrt(3);
            angles = (0:2) * 2 * pi / 3;
            baseOffsets = radius * [cos(angles); sin(angles)];
        case 'LINE'
            idx = (0:count-1) - (count-1)/2;
            baseOffsets = [zeros(1, count); idx * spacing];
        case {'LEADER4','ONEPLUSFOUR'}
            % V-shape (chevron): leader at the tip, two followers per row
            y1 = 0.7 * spacing;
            y2 = 1.4 * spacing;
            baseOffsets = [0, -spacing, -spacing, -2*spacing, -2*spacing;
                           0,  y1,       -y1,       y2,        -y2];
        case {'LEADER3','ONEPLUSTHREE'}
            % V-shape: two on first row, one centered on second row
            y1 = 0.7 * spacing;
            baseOffsets = [0, -spacing, -spacing, -2*spacing;
                           0,  y1,       -y1,       0];
        case 'CIRCLE'
            angles = 2 * pi * (0:count-1) / max(count, 1);
            baseOffsets = spacing * [cos(angles); sin(angles)];
        otherwise
            baseOffsets = zeros(2, max(count, 1));
    end
    if size(baseOffsets, 2) >= count
        offsets = baseOffsets(:, 1:count);
    else
        reps = ceil(count / size(baseOffsets, 2));
        offsets = repmat(baseOffsets, 1, reps);
        offsets = offsets(:, 1:count);
    end
end
